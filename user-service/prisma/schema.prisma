// This is your Prisma schema file
// Learn more: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// User model for authentication and user management
model User {
  id                       String         @id @default(uuid())
  email                    String         @unique
  password                 String? // Hashed with bcrypt (optional for OAuth users)
  name                     String
  googleId                 String?        @unique // Google OAuth ID
  authProvider             String         @default("local") // 'local' or 'google'
  emailVerified            Boolean        @default(false) // Email verification status
  emailVerificationToken   String?        @unique // Token for email verification
  emailVerificationExpires DateTime? // Expiration time for verification token
  passwordResetToken       String?        @unique // Token for password reset
  passwordResetExpires     DateTime? // Expiration time for reset token
  createdAt                DateTime       @default(now())
  updatedAt                DateTime       @updatedAt
  profileImage             String? // Optional profile image URL
  refreshTokens            RefreshToken[]

  // Friend relationships
  friendships Friendship[] @relation("UserFriendships")
  friendOf    Friendship[] @relation("FriendFriendships")

  // Direct messages
  sentMessages     DirectMessage[] @relation("SentMessages")
  receivedMessages DirectMessage[] @relation("ReceivedMessages")

  @@map("users")
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([expiresAt])
  @@index([userId])
  @@map("refresh_tokens")
}

model Friendship {
  id        String           @id @default(uuid())
  userId    String
  friendId  String
  status    FriendshipStatus @default(PENDING)
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  user   User @relation("UserFriendships", fields: [userId], references: [id], onDelete: Cascade)
  friend User @relation("FriendFriendships", fields: [friendId], references: [id], onDelete: Cascade)

  @@unique([userId, friendId])
  @@index([userId])
  @@index([friendId])
  @@index([status])
  @@index([userId, status])
  @@index([friendId, status])
  @@map("friendships")
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  BLOCKED
}

model DirectMessage {
  id          String   @id @default(uuid())
  senderId    String
  receiverId  String
  content     String   @db.Text
  attachments Json?    @default("[]")
  isRead      Boolean  @default(false)
  deletedAt   DateTime?
  editedAt    DateTime?
  replyToId   String?
  replyTo     DirectMessage?  @relation("DMReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies     DirectMessage[] @relation("DMReplies")
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  sender    User          @relation("SentMessages", fields: [senderId], references: [id], onDelete: Cascade)
  receiver  User          @relation("ReceivedMessages", fields: [receiverId], references: [id], onDelete: Cascade)
  reactions DMReaction[]

  @@index([senderId])
  @@index([receiverId])
  @@index([createdAt])
  @@index([senderId, receiverId, createdAt])
  @@index([receiverId, isRead])
  @@map("direct_messages")
}

model DMReaction {
  id        String         @id @default(uuid())
  messageId String
  message   DirectMessage  @relation(fields: [messageId], references: [id], onDelete: Cascade)
  userId    String
  emoji     String
  createdAt DateTime       @default(now())

  @@unique([messageId, userId, emoji])
  @@index([messageId])
  @@index([userId])
  @@map("dm_reactions")
}
